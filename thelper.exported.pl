#!/usr/bin/perl

#
# The MIT License (MIT)
#
# Copyright (c) 2015 yaalaa
#
# This file was generated by fatpack (https://metacpan.org/pod/fatpack)
# plus some additional magic steps.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

BEGIN
{
    my $requiredModules = [
        "Data::Dumper",
        "XML::Parser::Expat",
        "XML::Writer",
        "Text::CSV_XS",
    ];
    
    for my $curModule ( @{ $requiredModules } )
    {
        #printf "Checking module $curModule";
        
        if ( !eval "require $curModule; 1" )
        {
            printf "\nModule $curModule is required.\n\n";
            
            if ( $^O eq "darwin" || $^O =~ /^linux/ )
            {
                printf "You likely to run:\ncpan -i $curModule\n\n";
            }
            
            exit( -1 );
        }
        
        #printf "  - OK\n";
    }
}
##########################################################################


# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"AndroidStringResourceSaxHandler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANDROIDSTRINGRESOURCESAXHANDLER';
  #
  # The MIT License (MIT)
  #
  # Copyright (c) 2015 yaalaa
  #
  # Permission is hereby granted, free of charge, to any person obtaining a copy
  # of this software and associated documentation files (the "Software"), to deal
  # in the Software without restriction, including without limitation the rights
  # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  # copies of the Software, and to permit persons to whom the Software is
  # furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all
  # copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  # SOFTWARE.
  #
  #
  # SAX handler for Android String resource 
  #
  package AndroidStringResourceSaxHandler;
  
  use strict;
  use CommonUtils;
  use ItemTextRes;
  use ItemText;
  use Data::Dumper;
  use ItemCommentRes;
  
  
  sub new
  {
      my $class = shift;
  
      my $self = bless 
      {
          res => undef,
          acc => "",
          q => "",
          item => undef,
          comment => undef,
      }, $class;
  
      return $self;
  }
  
  #
  # Binds handlers to parser
  #
  # @param parser - parser
  #
  sub setHandlers
  {
      my ( $self, $parser ) = @_;
      
      $parser->setHandlers( 
          'Start' => sub{ $self->_start_element( @_ ) },
          'End'   => sub{ $self->_end_element( @_ ) },
          'Char'  => sub{ $self->_characters( @_ ) },
          'Comment'  => sub{ $self->_comment( @_ ) },
          );
  }
  
  #
  # Set resource file
  #
  # @param res - resource file as ItemFileRes
  #
  sub setRes
  {
      my ( $self, $res ) = @_;
      
      $self->{res} = $res;
  }
  
  sub _start_element 
  {
      my ( $self, $p, $el, @attrs ) = @_;
      
      #printf "AndroidStringResourceSaxHandler::_start_element: [%s] at %s\n", $el, $self->_getContext( $p );
      
      my %hattrs = @attrs;
      
      #printf "AndroidStringResourceSaxHandler::_start_element: [%s] attrs: %s\n\n%s\n", $el, Dumper( \%hattrs ), $p->recognized_string();
      
      if ( defined( $self->{comment} ) )
      {
          my $linesAfter = ( $self->{acc} =~ tr/\n/\n/ );
  
          #printf "AndroidStringResourceSaxHandler::_start_element: [%s] after comment[%s] nl=%d\n", $el, $self->{acc}, $linesAfter;
          
          $self->{comment}->setLinesAfter( $linesAfter );
      
          delete $self->{comment};
      }
      
      my $item = $self->{item};
      
      my $resetAcc = 1;
          
      if ( defined( $item ) ) # inside item
      {
          $resetAcc = 0;
      }
      
      if ( $el eq "string" ) # plain string
      {
          if ( !defined( $item ) ) # no item
          {
              $item = ItemTextRes->new( $hattrs{name}, {
                  plural => 0,
                  nontranslatable => ( $hattrs{translatable} eq "false" ? 1 : 0 ),
              } );
              
              $self->{item} = $item;
              
              $resetAcc = 1;
          }
          else
          {
              printf "AndroidStringResourceSaxHandler::_start_element: %s - inside item at %s\n", $el, $self->_getContext( $p );
          }
      } 
      elsif ( $el eq "plurals" ) # plural text
      {
          if ( !defined( $item ) ) # no item
          {
              $item = ItemTextRes->new( $hattrs{name}, {
                  plural => 1,
                  nontranslatable => ( $hattrs{translatable} eq "false" ? 1 : 0 ),
              } );
              
              $self->{item} = $item;
              
              $resetAcc = 1;
          }
          else
          {
              printf "AndroidStringResourceSaxHandler::_start_element: %s - inside item at %s\n", $el, $self->_getContext( $p );
          }
      }
      elsif ( $el eq "item" ) # item?
      {
          if ( !defined( $item ) )
          {
              printf "AndroidStringResourceSaxHandler::_start_element: item - no item\n";
          }
          elsif ( !$item->isPlural() )
          {
              printf "AndroidStringResourceSaxHandler::_start_element: item - not a plural\n";
          }
          
      
          if ( defined( $item ) && $item->isPlural() ) # it's for plural
          {
              my $q = $hattrs{quantity};
              
              if ( $q eq "" ) # no quantity 
              {
                  printf "AndroidStringResourceSaxHandler::_start_element: %s - no quantity specified at %s\n", $el, $self->_getContext( $p );
              }
  
              $self->{q} = $q;
          
              $resetAcc = 1;
          }
          else # it's for nothing
          {
              printf "AndroidStringResourceSaxHandler::_start_element: %s for nothing at %s\n", $el, $self->_getContext( $p );
          }
      }
      elsif ( $el eq "xliff:g" )
      {
          # do not warn
      }
      else # unsupported tag
      {
          if ( defined( $item ) )
          {
              printf "AndroidStringResourceSaxHandler::_start_element: unsupported [%s] at %s\n", $el, $self->_getContext( $p );
          }
      }
      
      if ( $resetAcc ) 
      {
          $self->{acc} = "";
      }
  }
  
  sub _end_element 
  {
      my ( $self, $p, $el ) = @_;
      
      #printf "AndroidStringResourceSaxHandler::_end_element: [%s] at %s\n", $el, $self->_getContext( $p );
      
      my $resetAcc = 1;
      my $resetQ = 1;
      my $resetItem = 1;
      
      my $item = $self->{item};
          
      if ( defined( $item ) ) # inside item
      {
          $resetAcc = 0;
          $resetQ = 0;
          $resetItem = 0;
      }
      
      if ( $el eq "string" ) # plain string
      {
          if ( defined $item )
          {
              my $s = $self->{acc};
              
              my $text = ItemText->new( $s );
              
              $item->setText( $text );
              
              if ( $s =~ /^\@(?:android:)?string\/.+$/ ) # looks like an alias
              {
                  $item->setAlias( 1 );
              }
              
              $self->{res}->addItem( $item );
          
              $resetAcc = 1;
              $resetQ = 1;
              $resetItem = 1;
          }
      } 
      elsif ( $el eq "plurals" ) # plural text
      {
          if ( defined $item )
          {
              $self->{res}->addItem( $item );
          
              $resetAcc = 1;
              $resetQ = 1;
              $resetItem = 1;
          }
      }
      elsif ( $el eq "item" ) # item?
      {
          if ( defined( $item ) && $item->isPlural() ) # it's for plural
          {
              my $item = $self->{item};
              my $q = $self->{q};
              my $s = $self->{acc};
              
              my $text = ItemText->new( $s );
              
              $item->setVariant( $q, $text );
              
              $resetAcc = 1;
              $resetQ = 1;
              $resetItem = 0;
          }
      }
      
      if ( $resetAcc ) 
      {
          $self->{acc} = "";
      }
      
      if ( $resetQ ) 
      {
          $self->{q} = "";
      }
      
      if ( $resetItem )
      {
          delete $self->{item};
      }
  }
  
  sub _characters
  {
      my ( $self, $p, $data ) = @_;
      
      #printf "AndroidStringResourceSaxHandler::_characters: [%s]\n", $data;
      
      $self->{acc} .= $data;
  }
  
  sub _comment
  {
      my ( $self, $p, $data ) = @_;
  
      #printf "AndroidStringResourceSaxHandler::_comment: [%s]\n", $data;
      
      my $linesBefore = ( $self->{acc} =~ tr/\n/\n/ );
      
      my $item = ItemCommentRes->new( $data, $linesBefore );
      
      $self->{res}->addItem( $item );
      
      $self->{comment} = $item;
      
      $self->{acc} = "";
  }
  
  #
  # Retrieves context string
  #
  # @param parser - parser
  #
  # @return context string
  #
  sub _getContext
  {
      my ( $self, $p ) = @_;
      
      return $self->{res}->getFileName()." line ".$p->current_line();
  }
  
  1;
ANDROIDSTRINGRESOURCESAXHANDLER

$fatpacked{"CommonUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMONUTILS';
  #
  # The MIT License (MIT)
  #
  # Copyright (c) 2015 yaalaa
  #
  # Permission is hereby granted, free of charge, to any person obtaining a copy
  # of this software and associated documentation files (the "Software"), to deal
  # in the Software without restriction, including without limitation the rights
  # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  # copies of the Software, and to permit persons to whom the Software is
  # furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all
  # copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  # SOFTWARE.
  #
  #
  # Common utilities
  #
  package CommonUtils;
  
  use strict;
  use File::stat;
  
  
  sub TrimStr
  {
    my $str = shift( @_ );
    
    $str =~ s/^\s+([^\s].*)$/$1/g;
    $str =~ s/^(.*[^\s])\s+$/$1/g;
    
    return $str;
  }
  
  sub ToStraightSlash
  {
    my $src = shift( @_ );
    
    $src =~ s/\\/\//g;
    
    return $src;
  }
  
  sub ToBackSlash
  {
    my $src = shift( @_ );
    
    $src =~ s/\//\\/g;
    
    return $src;
  }
  
  sub GetTimeStr
  {
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime( time );
  
    return sprintf( "%04d.%02d.%02d %02d:%02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min, $sec );
  }
  
  sub getFileContent
  {
      my $out;
      
      my $srcFile;
  
      {{
          my $srcFileName = shift( @_ );
          
          if ( $srcFileName eq "" ) # no source filename
          {
              printf "%s CommonUtils::getFileContent: no source filename \n", CommonUtils::GetTimeStr();
              last;
          }
          
          if ( !open( $srcFile, "<$srcFileName" ) ) # failed
          {
              printf "%s CommonUtils::getFileContent: open[%s] failed: %s \n", CommonUtils::GetTimeStr(), $srcFileName, $!;
              last;
          }
  
          binmode( $srcFile );
  
          my $srcStat = stat( $srcFile );
  
          my $srcDataLen = $srcStat->size;
  
          if ( $srcDataLen <= 0 ) # no data 
          {
              last;
          }
          
          my $srcData;
          
          if ( !read( $srcFile, $srcData, $srcDataLen ) ) # failed
          {
              printf "%s CommonUtils::getFileContent: read[%s] failed: %s \n", CommonUtils::GetTimeStr(), $srcFileName, $!;
              last;
          }
  
          if ( length( $srcData ) != $srcDataLen ) # sizes mismatch
          {
              printf "%s CommonUtils::getFileContent: input file read error (need %d, read %d) [%s]\n", CommonUtils::GetTimeStr(), $srcDataLen, length( $srcData ), $srcFileName;
              last;
          }
  
          $out = $srcData;
      }}
      
      if ( defined( $srcFile ) ) 
      {
          close( $srcFile );
      }
      
      return $out;
  }
  
  
  
  1;
COMMONUTILS

$fatpacked{"ItemAndroidFileRes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ITEMANDROIDFILERES';
  #
  # The MIT License (MIT)
  #
  # Copyright (c) 2015 yaalaa
  #
  # Permission is hereby granted, free of charge, to any person obtaining a copy
  # of this software and associated documentation files (the "Software"), to deal
  # in the Software without restriction, including without limitation the rights
  # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  # copies of the Software, and to permit persons to whom the Software is
  # furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all
  # copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  # SOFTWARE.
  #
  #
  # Android resource file
  #
  package ItemAndroidFileRes;
  
  
  use strict;
  use parent qw(ItemFileRes);
  use CommonUtils;
  use Scalar::Util qw(reftype blessed);
  use XML::Writer;
  use IO::File;
  
  #
  # Initializes object
  # 
  # @param fileName - filename
  # @param source   - type of source of the file (i.e. android resource, etc.)
  # @param lang     - language
  #
  # @return initialized object
  #
  sub new
  {
      my ( $class, $fileName, $source, $lang ) = @_;
      
      my $self = bless $class->SUPER::new( $fileName, $source, $lang ), $class;
      
      $self->{namespaces} = {};
  
      return $self;
  }
  
  #
  # Saves to XML file
  #
  # @param fileName - filename to write to
  #
  # @return !=0, if succeeded
  #
  sub saveToXml
  {
      my ( $self, $fileName, $options ) = @_;
      
      my $out = 0;
      
      my $file;
      
      {{
          my $optNotTranslatable = 0;
          my $optAlias = 0;
          
          if ( reftype $options eq "HASH" )
          {
              if ( $options->{NOTTRANSLATABLE} )
              {
                  $optNotTranslatable = 1;
              }
              
              if ( $options->{ALIAS} )
              {
                  $optAlias = 1;
              }
          }
      
          if ( $fileName eq "" ) # no filename
          {
              printf "ItemAndroidFileRes::saveToXml: no filename specified\n";
              last;
          }
          
          if ( !open( $file, ">:raw:encoding(UTF-8)", $fileName ) ) # failed
          {
              printf "ItemAndroidFileRes::saveToXml: open failed[%s]: %s\n", $fileName, $!;
              last;
          }
          
          my $writer = XML::Writer->new( 
              #OUTPUT => "self",
              OUTPUT => $file,
              ENCODING => "utf-8",
              CHECK_PRINT => 1,
              );
          
          my $indent = " "x4;
          my $newline = "\n";
          
          $writer->xmlDecl();
          $writer->startTag( "resources" );
          $writer->characters( $newline );
          
          for my $curItem ( @{ $self->{itemsExt} } )
          {
              if ( $curItem->isa( "ItemTextRes" ) ) # text resource
              {
                  if ( !$curItem->isTranslatable() && !$optNotTranslatable )
                  {
                      next;
                  }
                  
                  if ( $curItem->isAlias() && !$optAlias )
                  {
                      next;
                  }
                  
                  $writer->characters( $newline.$indent );
                  
                  if ( !$curItem->isPlural() ) # plain text
                  {
                      my @attrs;
                      
                      push( @attrs, "name", $curItem->getId() );
                      
                      if ( !$curItem->isTranslatable() )
                      {
                          push( @attrs, "translatable", "false" );
                      }
                      
                      $writer->startTag( "string",  
                          @attrs,
                          );
                          
                      $writer->characters( $curItem->getText()->getData() );
                      
                      $writer->endTag( "string" );
                  }
                  else # plural text
                  {
                      my @attrs;
                      
                      push( @attrs, "name", $curItem->getId() );
                      
                      if ( !$curItem->isTranslatable() )
                      {
                          push( @attrs, "translatable", "false" );
                      }
                      
                      $writer->startTag( "plurals",  
                          @attrs,
                          );
                          
                      for my $curVariant ( @$ItemTextRes::VARIANTS ) 
                      {
                          my $text = $curItem->getVariant( $curVariant );
                          
                          if ( defined( $text ) )
                          {
                              $writer->characters( $newline. ( $indent x 2 ) );
  
                              $writer->startTag( "item",  
                                  "quantity" => $curVariant,
                                  );
                           
                              $writer->characters( $text->getData() );
                              
                              $writer->endTag( "item" );
                          }
                      }
                          
                      $writer->characters( $newline.$indent );
                      $writer->endTag( "plurals" );
                  }
              }
              else # comment
              {
                  $writer->characters( ( $newline x $curItem->getLinesBefore() ).$indent );
                  $writer->comment( CommonUtils::TrimStr( $curItem->getData() ) );
                  
                  my $linesAfter = $curItem->getLinesAfter();
                  
                  if ( $linesAfter > 1 )
                  {
                      $writer->characters( $newline x ( $linesAfter - 1 ) );
                  }
              }
          }
          
          $writer->characters( $newline x 2 );
          $writer->endTag( "resources" );
          $writer->end();
          
          $out = 1;
      }}
      
      if ( defined( $file ) )
      {
          close( $file );
      }
      
      return $out;
  }
  
  
  1;
ITEMANDROIDFILERES

$fatpacked{"ItemAndroidProjectRes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ITEMANDROIDPROJECTRES';
  #
  # The MIT License (MIT)
  #
  # Copyright (c) 2015 yaalaa
  #
  # Permission is hereby granted, free of charge, to any person obtaining a copy
  # of this software and associated documentation files (the "Software"), to deal
  # in the Software without restriction, including without limitation the rights
  # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  # copies of the Software, and to permit persons to whom the Software is
  # furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all
  # copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  # SOFTWARE.
  #
  #
  # Android resource project
  #
  package ItemAndroidProjectRes;
  
  
  use strict;
  use parent qw(ItemProjectRes);
  use CommonUtils;
  use XML::Parser::Expat;
  use AndroidStringResourceSaxHandler;
  use ItemFileRes;
  use ItemAndroidFileRes;
  use Locale::Language;
  use Locale::Country;
  
  
  #
  # Source string
  #
  our $SOURCE = "android";
  #
  # Resource root folder
  #
  my $RES_DIR_ROOT = "res";
  #
  # Resource sub-folder
  #
  my $RES_DIR_SUB = "values";
  #
  # Resource filename
  #
  my $RES_FILE_NAME = "strings.xml";
  #
  # Base resource filename
  #
  my $RES_BASE = $RES_DIR_ROOT."/".$RES_DIR_SUB."/".$RES_FILE_NAME;
  
  #
  # Initializes object
  # 
  # @param root - project root folder
  #
  # @return initialized object
  #
  sub new
  {
      my ( $class, $root ) = @_;
  
      my $self = $class->SUPER::new( $root, $SOURCE );
      
      return bless $self, $class;
  }
  
  #
  # Retrieves list of languages of existing translations
  #
  # @return list of languages of existing translations(hash: lang->filename)
  #
  sub _loadLangs
  {
      my $self = shift;
      
      my $out;
      
      {{
          my $resDir = $self->{root}."/".$RES_DIR_ROOT;
          
          if ( ! -d $resDir )  # no root resource folder
          {
              last;
          }
  
          
          my @allLangCodes = all_language_codes();
          my @allCountryCodes = all_country_codes( LOCALE_CODE_ALPHA_2 );
          
          my $langSuffixRegex = "(?:".join( "|", @allLangCodes ).")(?:r(?:".join( "|", @allCountryCodes )."))?";
  
          
          my @subDirs;
  
          my $resDirH;
  
          if ( !opendir( $resDirH, $resDir ) )
          {
              printf "ItemAndroidProjectRes::_loadLangs: opendir[%s] failed [%s]\n", $resDir, $!;
              last;
          }
  
          @subDirs = grep( /^values-${langSuffixRegex}$/i ,readdir( $resDirH ) );
  
          closedir( $resDirH );
  
          my $langs = {};
          
          for my $curDir ( @subDirs )
          {
              my $curFile = $resDir."/".$curDir."/".$RES_FILE_NAME;
              
              if ( ! -f $curFile ) # no resource file
              {
                  next;
              }
              
              $curDir =~ /^values-(.+)$/;
              
              $langs->{$1} = $RES_DIR_ROOT."/".$curDir."/".$RES_FILE_NAME;
          }
          
          $out = $langs;
      }}
      
      return $out;
  }
  
  #
  # Creates resource file object
  #
  # @param fileName - filename relative to project root folder
  # @param lang     - language
  #
  # @return resource file as ItemFileRes, if succeeded
  #
  sub _createRes
  {
      my ( $self, $fileName, $lang ) = @_;
      
      return ItemAndroidFileRes->new( $fileName, $self->{source}, $lang );
  }
  
  #
  # Loads resource file
  #
  # @param fileName - filename relative to project root folder
  # @param lang     - language
  #
  # @return resource file as ItemFileRes, if succeeded
  #
  sub _loadRes
  {
      my ( $self, $fileName, $lang ) = @_;
      
      my $out;
      
      {{
          my $resFileName = $self->{root}."/".$fileName;
          
          if ( ! -f $resFileName )  # no resource file
          {
              #printf "ItemAndroidProjectRes::_loadRes: file not found [%s]\n", $resFileName;
              last;
          }
          
          my $resData = CommonUtils::getFileContent( $resFileName );
          
          if ( length( $resData ) <= 0 ) # no data
          {
              last;
          }
          
          my $res = $self->_createRes( $resFileName, $lang );
          
          $res->setFileData( $resData );
          
          my $handler = AndroidStringResourceSaxHandler->new;
          
          my $parser = XML::Parser::Expat->new;
          
          $handler->setRes( $res );
          $handler->setHandlers( $parser );
          
          $parser->parsestring( $resData );
          
          $out = $res;
      }}
      
      return $out;
  }
  
  #
  # Loads base resource file
  #
  # @return resource file as ItemFileRes, if succeeded
  #
  sub _loadResBase
  {
      my $self = shift;
      
      return $self->_loadRes( $RES_BASE, "" );
  }
  
  #
  # Retrieves resource file for specified language
  #
  # @param lang - language
  #
  # @return resource file as ItemFileRes, if succeeded
  #
  sub _loadResForLang
  {
      my ( $self, $lang ) = @_;
      
      return $self->_loadRes( $RES_DIR_ROOT."/values-".$lang."/".$RES_FILE_NAME, $lang );
  }
  
  
  1;
  
ITEMANDROIDPROJECTRES

$fatpacked{"ItemCommentRes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ITEMCOMMENTRES';
  #
  # The MIT License (MIT)
  #
  # Copyright (c) 2015 yaalaa
  #
  # Permission is hereby granted, free of charge, to any person obtaining a copy
  # of this software and associated documentation files (the "Software"), to deal
  # in the Software without restriction, including without limitation the rights
  # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  # copies of the Software, and to permit persons to whom the Software is
  # furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all
  # copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  # SOFTWARE.
  #
  # Comment resource
  #
  package ItemCommentRes;
  
  
  use strict;
  use parent qw(ItemText);
  use CommonUtils;
  
  
  #
  # Initializes object
  # 
  # @param s           - text string
  # @param linesBefore - number of empty lines before comment
  #
  # @return initialized object
  #
  sub new
  {
      my ( $class, $s, $linesBefore ) = @_;
      
      my $self = bless $class->SUPER::new( $s ), $class;
  
      $self->{linesBefore} = $linesBefore + 0;
      $self->{linesAfter} = 0;
      
      return $self;
  }
  
  #
  # Retrieves number of empty lines before comment
  # 
  # @return number of empty lines before comment
  #
  sub getLinesBefore
  {
      my $self = shift;
      
      return $self->{linesBefore};
  }
  
  #
  # Retrieves number of empty lines after comment
  # 
  # @return number of empty lines after comment
  #
  sub getLinesAfter
  {
      my $self = shift;
      
      return $self->{linesAfter};
  }
  
  #
  # Retrieves number of empty lines after comment
  # 
  # @return number of empty lines after comment
  #
  sub setLinesAfter
  {
      my ( $self, $linesAfter ) = @_;
      
      $self->{linesAfter} = $linesAfter + 0;
  }
  
  
  1;
ITEMCOMMENTRES

$fatpacked{"ItemFileRes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ITEMFILERES';
  #
  # The MIT License (MIT)
  #
  # Copyright (c) 2015 yaalaa
  #
  # Permission is hereby granted, free of charge, to any person obtaining a copy
  # of this software and associated documentation files (the "Software"), to deal
  # in the Software without restriction, including without limitation the rights
  # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  # copies of the Software, and to permit persons to whom the Software is
  # furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all
  # copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  # SOFTWARE.
  #
  #
  # Resource file
  #
  package ItemFileRes;
  
  
  use strict;
  use CommonUtils;
  use Text::CSV_XS;
  use ItemTextRes;
  use Scalar::Util qw(blessed);
  
  
  #
  # Initializes object
  # 
  # @param fileName - filename
  # @param source   - type of source of the file (i.e. android resource, etc.)
  # @param lang     - language
  #
  # @return initialized object
  #
  sub new
  {
      my ( $class, $fileName, $source, $lang ) = @_;
  
      my $self = bless 
      {
          fileName => $fileName,
          source => $source,
          lang => $lang,
          fileData => undef,
          items => [],
          itemsExt => [],
          plains => {},
          plurals => {},
      }, $class;
      
      return $self;
  }
  
  #
  # Retrieves filename
  #
  # @return filename
  #
  sub getFileName
  {
      my $self = shift;
  
      return $self->{fileName};
  }
  
  #
  # Retrieves source
  #
  # @return source
  #
  sub getSource
  {
      my $self = shift;
  
      return $self->{source};
  }
  
  #
  # Retrieves language
  #
  # @return language
  #
  sub getLang
  {
      my $self = shift;
  
      return $self->{lang};
  }
  
  #
  # Retrieves file data
  #
  # @return file data
  #
  sub getFileData
  {
      my $self = shift;
  
      return $self->{fileData};
  }
  
  #
  # Sets file data
  #
  # @param data - file data
  #
  sub setFileData
  {
      my ( $self, $data ) = @_;
  
      $self->{fileData} = $data;
  }
  
  #
  # Adds item
  #
  # @param item - text resource as ItemTextRes
  #
  # @return !=0, if succeeded
  #
  sub addItem
  {
      my ( $self, $item ) = @_;
  
      my $out = 0;
      
      {{
          if ( blessed $item && $item->isa( "ItemTextRes" ) ) # ItemTextRes
          {
              my $id = $item->getId();
              
              if ( $id eq "" ) # no ID
              {
                  printf "ItemFileRes::addItem: no id\n";
                  last;
              }
              
              push( @{ $self->{items} }, $item );
              
              if ( $item->isPlural() ) # it's plural
              {
                  $self->{plurals}->{$id} = $item;
              }
              else # plain
              {
                  $self->{plains}->{$id} = $item;
              }
          }
          elsif ( blessed $item && $item->isa( "ItemCommentRes" ) ) # instance of ItemCommentRes
          {
              # do nothing for now
          }
          else
          {
              printf "ItemFileRes::addItem: unsupported type:[%s]\n", blessed( $item );
              last;
          }
          
          push( @{ $self->{itemsExt} }, $item );
          
          $out = 1;
      }}
      
      return $out;
  }
  
  #
  # Retrieves items list
  #
  # @return items list
  #
  sub getItems
  {
      my $self = shift;
  
      return $self->{items};
  }
  
  #
  # Retrieves extended items list
  #
  # @return extended items list
  #
  sub getItemsExt
  {
      my $self = shift;
  
      return $self->{itemsExt};
  }
  
  #
  # Retrieves plain item with specified ID
  #
  # @param id - item ID
  #
  # @return item as ItemTextRes
  #
  sub getItemPlainById
  {
      my ( $self, $id ) = @_;
      
      my $out;
      
      {{
          if ( $id eq "" ) # no ID
          {
              last;
          }
          
          $out = $self->{plains}->{$id};
      }}
      
      return $out;
  }
  
  #
  # Retrieves plural item with specified ID
  #
  # @param id - item ID
  #
  # @return item as ItemTextRes
  #
  sub getItemPluralById
  {
      my ( $self, $id ) = @_;
      
      my $out;
      
      {{
          if ( $id eq "" ) # no ID
          {
              last;
          }
          
          $out = $self->{plurals}->{$id};
      }}
      
      return $out;
  }
  
  #
  # Retrieves item with specified ID
  #
  # @param id     - item ID
  # @param plural - != 0 to look for plural
  #
  # @return item as ItemTextRes
  #
  sub getItemById
  {
      my ( $self, $id, $plural ) = @_;
      
      return $plural ? $self->getItemPluralById( $id ) : $self->getItemPlainById( $id );
  }
  
  #
  # Saves items to CSV file
  #
  # @param fileName - output CSV file name
  #
  # @return !=0, if succeeded
  #
  sub saveItemsToCsv
  {
      my ( $self, $fileName ) = @_;
      
      my $out = 0;
  
      my $file;
      
      {{
          if ( $fileName eq "" ) # no filename
          {
              printf "ItemFileRes::saveItemsToCsv: no filename\n";
              last;
          }
          
          if ( !open( $file, ">:utf8", $fileName ) ) # failed
          {
              printf "ItemFileRes::saveItemsToCsv: open failed[%s]: %s\n", $fileName, $!;
              last;
          }
          
          my $csv = Text::CSV_XS->new( { binary => 1, eol => $/ } );
  
          if ( !$csv->print( $file, [ "ID", "Modifier", "Original" ] ) ) # failed
          {
              printf "ItemFileRes::saveItemsToCsv: csv::print failed: %s\n", $csv->status();
              last;
          }
          
          my $ok = 1;
          
          foreach my $item ( @{ $self->{items} } )
          {
              if ( !$item->isPlural() )
              {
                  if ( !$csv->print( $file, [ $item->getId(), "", $item->getText()->getData() ] ) ) # failed
                  {
                      printf "ItemFileRes::saveItemsToCsv: csv::print failed: %s\n", $csv->status();
                      $ok = 0;
                      last;
                  }
              } else 
              {
              }
          }
          
          if ( !$ok )
          {
              last;
          }
          
          $out = 1;
      }}
      
      if ( defined( $file ) )
      {
          close( $file );
      }
      
      return $out;
  }
  
  #
  # Load items from CSV file
  #
  # @param fileName - output CSV file name
  #
  # @return read items count
  #
  sub loadItemsFromCsv
  {
      my ( $self, $fileName ) = @_;
      
      my $out = 0;
  
      my $file;
      
      {{
          if ( $fileName eq "" ) # no filename
          {
              printf "ItemFileRes::loadItemsFromCsv: no filename\n";
              last;
          }
          
          if ( !open( $file, "<:encoding(UTF-8)", $fileName ) ) # failed
          {
              printf "ItemFileRes::loadItemsFromCsv: open failed[%s]: %s\n", $fileName, $!;
              last;
          }
          
          my $csv = Text::CSV_XS->new( { binary => 1 } );
  
          my $data = $csv->getline_all( $file, 2 );
          
          if ( !defined( $data ) )
          {
              printf "ItemFileRes::loadItemsFromCsv: getline_all failed[%s]\n", $fileName;
              last;
          }
          
          my $plural;
          
          my $lineIdx = 2;
          
          for my $row ( @{ $data } )
          {
              my ( $id, $variant, $original, $translation ) = @$row;
              
              if ( defined( $translation ) && $translation eq "" )
              {
                  undef $translation;
              }
              
              if ( defined( $variant ) && $variant eq "" )
              {
                  undef $variant;
              }
              
              #printf "ItemFileRes::loadItemsFromCsv: id[%s] v[%s] t[%s]\n", $id, $variant, $translation;
              
              if ( $id ne "" ) # ID means new item
              {
                  if ( defined( $plural ) )
                  {
                      #printf "ItemFileRes::loadItemsFromCsv: to add plural: empty=%d\n", $plural->isEmpty();
                      
                      if ( !$plural->isEmpty() )
                      {
                          if ( $self->addItem( $plural ) )
                          {
                              $out++;
                          }
                      }
                      
                      undef $plural;
                  }
                  
                  if ( defined( $translation ) ) # plain text
                  {
                      my $item = ItemTextRes->new( $id, {
                          plural => 0,
                          } );
                          
                      my $text = ItemText->new( $translation );
                      
                      $item->setText( $text );
  
                      if ( $self->addItem( $item ) )
                      {
                          $out++;
                      }
                  }
                  else # guess plural
                  {
                      #printf "ItemFileRes::loadItemsFromCsv: start plural[%s]\n", $id;
                      
                      $plural = ItemTextRes->new( $id, {
                          plural => 1,
                          } );
                  }
              }
              else # no ID might be plural 
              {
                  if ( defined( $plural ) ) # plural is in progress
                  {
                      if ( defined( $variant ) ) # another variant for plural
                      {
                          if ( defined( $translation ) ) # has translation
                          {
                              #printf "ItemFileRes::loadItemsFromCsv: for plural[%s] add v[%s] t[%s]\n", $id, $variant, $translation;
                              
                              my $text = ItemText->new( $translation );
                              
                              $plural->setVariant( $variant, $text );
                          }
                          else # no translation
                          {
                              # skip it 
                          }
                      }
                      else # no variant
                      {
                          # neither ID nor variant - guess it's blank line
                          # skip it
                      }
                  }
                  else # no plural in progress
                  {
                      # neiher ID nor plural -- strange a bit, but it might be blank line too
                      # skip it
                  }
              }
              
              $lineIdx++;
          }
  
          # complete last plural
          if ( defined( $plural ) )
          {
              #printf "ItemFileRes::loadItemsFromCsv: to complete plural: empty=%d\n", $plural->isEmpty();
              
              if ( !$plural->isEmpty() )
              {
                  if ( $self->addItem( $plural ) )
                  {
                      $out++;
                  }
              }
              
              undef $plural;
          }
      }}
      
      if ( defined( $file ) )
      {
          close( $file );
      }
      
      return $out;
  }
  
  
  1;
ITEMFILERES

$fatpacked{"ItemIosFileRes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ITEMIOSFILERES';
  #
  # The MIT License (MIT)
  #
  # Copyright (c) 2015 yaalaa
  #
  # Permission is hereby granted, free of charge, to any person obtaining a copy
  # of this software and associated documentation files (the "Software"), to deal
  # in the Software without restriction, including without limitation the rights
  # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  # copies of the Software, and to permit persons to whom the Software is
  # furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all
  # copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  # SOFTWARE.
  #
  #
  # iOS resource file
  #
  package ItemIosFileRes;
  
  
  use strict;
  use parent qw(ItemFileRes);
  use CommonUtils;
  use Scalar::Util qw(reftype blessed);
  use ItemText;
  use ItemCommentRes;
  
  
  #
  # Initializes object
  # 
  # @param fileName - filename
  # @param source   - type of source of the file (i.e. android resource, etc.)
  # @param lang     - language
  #
  # @return initialized object
  #
  sub new
  {
      my ( $class, $fileName, $source, $lang ) = @_;
      
      my $self = bless $class->SUPER::new( $fileName, $source, $lang ), $class;
  
      return $self;
  }
  
  #
  # Loads items from the file
  #
  # @param fileName - filename
  #
  # @return !=0, if succeeded
  #
  sub load
  {
      my ( $self, $fileName ) = @_;
      
      my $out = 0;
      
      my $file;
      
      {{
          if ( !defined( $fileName ) || $fileName eq "" ) # no filename
          {
              printf "ItemIosFileRes::load: no filename specified\n";
              last;
          }
          
          if ( ! -f $fileName ) # not found
          {
              printf "ItemIosFileRes::load: file is not found[%s]\n", $fileName;
              last;
          }
          
          if ( !open( $file, "<:raw:encoding(UTF-16LE)", $fileName ) ) # failed
          {
              printf "ItemIosFileRes::load: open[%s] failed: %s\n", $fileName, $!;
              last;
          }
          
          my $comment = "";
          
          my $ok = 1;
          
          while ( <$file> )
          {
              my $s = $_;
              
              # cleanup eol
              $s =~ s/\n\r?$/\n/;
  
              #printf "ItemIosFileRes::load: s[%s]\n", $s;
              
              if ( $s =~ /^\s*"([a-zA-Z_\.-]+)"\s*=\s*"(.+)"\s*;\s*\n?$/ ) # ID
              {
                  my $id = $1;
                  my $val = $2;
  
                  $val =~ s/\\"/"/g;
                  $val =~ s/\\\\/\\/g;
                  
                  #printf "ItemIosFileRes::load: id[%s] v[%s]\n", $id, $val;
                  
                  if ( $comment ne "" )
                  {
                      #printf "ItemIosFileRes::load: comment[%s]\n", $comment;
                      
                      my $item = ItemCommentRes->new( $comment, 0 );
                      
                      if ( !$self->addItem( $item ) ) # failed
                      {
                          printf "ItemIosFileRes::load: addItem(comment) failed\n";
                          last;
                      }
                      
                      $comment = "";
                  }
  
                  my $item = ItemTextRes->new( $id );
                      
                  my $text = ItemText->new( $val );
                  
                  $item->setText( $text );
                  
                  if ( !$self->addItem( $item ) ) # failed
                  {
                      printf "ItemIosFileRes::load: addItem(text) failed\n";
                      $ok = 0;
                      last;
                  }
              }
              else
              {
                  $comment .= $s;
              }
          }
          
          if ( !$ok ) # failed
          {
              last;
          }
          
          if ( $comment ne "" )
          {
              #printf "ItemIosFileRes::load: comment.last[%s]\n", $comment;
              
              my $item = ItemCommentRes->new( $comment, 0 );
              
              if ( !$self->addItem( $item ) ) # failed
              {
                  printf "ItemIosFileRes::load: addItem(comment.last) failed\n";
                  last;
              }
          }
          
          $out = 1;
      }}
      
      if ( defined( $file ) )
      {
          close( $file );
      }
      
      return $out;
  }
  
  #
  # Saves to file
  #
  # @param fileName - filename to write to
  #
  # @return !=0, if succeeded
  #
  sub save
  {
      my ( $self, $fileName, $options ) = @_;
      
      my $out = 0;
      
      my $file;
      
      {{
          my $optNotTranslatable = 0;
          my $optAlias = 0;
          
          if ( reftype $options eq "HASH" )
          {
              if ( $options->{NOTTRANSLATABLE} )
              {
                  $optNotTranslatable = 1;
              }
              
              if ( $options->{ALIAS} )
              {
                  $optAlias = 1;
              }
          }
      
          if ( $fileName eq "" ) # no filename
          {
              printf "ItemIosFileRes::save: no filename specified\n";
              last;
          }
          
          if ( !open( $file, ">:raw:encoding(UTF-16LE)", $fileName ) ) # failed
          {
              printf "ItemIosFileRes::save: open failed[%s]: %s\n", $fileName, $!;
              last;
          }
          
          my $newline = "\n";
          
          my $ok = 1;
          
          for my $curItem ( @{ $self->{itemsExt} } )
          {
              if ( $curItem->isa( "ItemTextRes" ) ) # text resource
              {
                  if ( !$curItem->isTranslatable() && !$optNotTranslatable )
                  {
                      next;
                  }
                  
                  if ( $curItem->isAlias() && !$optAlias )
                  {
                      next;
                  }
                  
                  if ( !$curItem->isPlural() ) # plain text
                  {
                      my $id = $curItem->getId();
                      my $text = $curItem->getText()->getData();
                      
                      $text =~ s/\\/\\\\/g;
                      $text =~ s/"/\\"/g;
                      
                      $ok = printf $file "\"%s\" = \"%s\";".$newline, $id, $text;
                      
                      if ( !$ok ) # failed
                      {
                          printf "ItemIosFileRes::save: printf failed\n";
                          last;
                      }
                  }
                  else # plural text
                  {
                      # TODO support
                  }
              }
              else # comment
              {
                  $ok = print $file $curItem->getData();
                      
                  if ( !$ok ) # failed
                  {
                      printf "ItemIosFileRes::save: print(comment) failed\n";
                      last;
                  }
              }
          }
          
          if ( !$ok ) # failed
          {
              last;
          }
          
          $out = 1;
      }}
      
      if ( defined( $file ) )
      {
          close( $file );
      }
      
      return $out;
  }
  
  
  1;
ITEMIOSFILERES

$fatpacked{"ItemIosProjectRes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ITEMIOSPROJECTRES';
  #
  # The MIT License (MIT)
  #
  # Copyright (c) 2015 yaalaa
  #
  # Permission is hereby granted, free of charge, to any person obtaining a copy
  # of this software and associated documentation files (the "Software"), to deal
  # in the Software without restriction, including without limitation the rights
  # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  # copies of the Software, and to permit persons to whom the Software is
  # furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all
  # copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  # SOFTWARE.
  #
  #
  # iOS resource project
  #
  package ItemIosProjectRes;
  
  
  use strict;
  use parent qw(ItemProjectRes);
  use CommonUtils;
  use ItemIosFileRes;
  
  
  #
  # Source string
  #
  our $SOURCE = "ios";
  #
  # Resource sub-folder suffix
  #
  my $RES_DIR_SUFFIX = ".lproj";
  #
  # Resource filename
  #
  my $RES_FILE_NAME = "Localizable.strings";
  #
  # Base resource languag
  #
  my $RES_BASE_LANG = "en";
  #
  # Base resource folder name
  #
  my $RES_DIR_BASE = $RES_BASE_LANG.$RES_DIR_SUFFIX;
  #
  # Base resource filename
  #
  my $RES_BASE = $RES_DIR_BASE."/".$RES_FILE_NAME;
  
  #
  # Initializes object
  # 
  # @param root - project root folder
  #
  # @return initialized object
  #
  sub new
  {
      my ( $class, $root ) = @_;
  
      my $self = $class->SUPER::new( $root, $SOURCE );
      
      return bless $self, $class;
  }
  
  #
  # Retrieves list of languages of existing translations
  #
  # @return list of languages of existing translations(hash: lang->filename)
  #
  sub _loadLangs
  {
      my $self = shift;
      
      my $out;
      
      {{
          my $resDir = $self->{root};
          
          if ( ! -d $resDir )  # no root resource folder
          {
              last;
          }
          
          my @subDirs;
  
          my $resDirH;
  
          if ( !opendir( $resDirH, $resDir ) )
          {
              printf "ItemIosProjectRes::_loadLangs: opendir[%s] failed [%s]\n", $resDir, $!;
              last;
          }
  
          @subDirs = grep( /^[a-zA-Z_-]+\.lproj$/i ,readdir( $resDirH ) );
  
          closedir( $resDirH );
  
          my $langs = {};
          
          for my $curDir ( @subDirs )
          {
              my $curFile = $resDir."/".$curDir."/".$RES_FILE_NAME;
              
              if ( ! -f $curFile ) # no resource file
              {
                  next;
              }
              
              $curDir =~ /^([a-zA-Z_-]+)\.lproj$/;
              
              if ( $1 ne $RES_BASE_LANG )
              {
                  $langs->{$1} = $curDir."/".$RES_FILE_NAME;
              }
          }
          
          $out = $langs;
      }}
      
      return $out;
  }
  
  #
  # Creates resource file object
  #
  # @param fileName - filename relative to project root folder
  # @param lang     - language
  #
  # @return resource file as ItemFileRes, if succeeded
  #
  sub _createRes
  {
      my ( $self, $fileName, $lang ) = @_;
      
      return ItemIosFileRes->new( $fileName, $self->{source}, $lang );
  }
  
  #
  # Loads resource file
  #
  # @param fileName - filename relative to project root folder
  # @param lang     - language
  #
  # @return resource file as ItemFileRes, if succeeded
  #
  sub _loadRes
  {
      my ( $self, $fileName, $lang ) = @_;
      
      my $out;
      
      {{
          my $resFileName = $self->{root}."/".$fileName;
          
          if ( ! -f $resFileName )  # no resource file
          {
              #printf "ItemIosProjectRes::_loadRes: file not found [%s]\n", $resFileName;
              last;
          }
          
          my $res = $self->_createRes( $resFileName, $lang );
          
          if ( !$res->load( $resFileName ) ) # failed
          {
              printf "ItemIosProjectRes::_loadRes: load failed on [%s]\n", $resFileName;
              last;
          }
          
          $out = $res;
      }}
      
      return $out;
  }
  
  #
  # Loads base resource file
  #
  # @return resource file as ItemFileRes, if succeeded
  #
  sub _loadResBase
  {
      my $self = shift;
      
      return $self->_loadRes( $RES_BASE, "" );
  }
  
  #
  # Retrieves resource file for specified language
  #
  # @param lang - language
  #
  # @return resource file as ItemFileRes, if succeeded
  #
  sub _loadResForLang
  {
      my ( $self, $lang ) = @_;
      
      return $self->_loadRes( $lang.$RES_DIR_SUFFIX."/".$RES_FILE_NAME, $lang );
  }
  
  
  1;
  
ITEMIOSPROJECTRES

$fatpacked{"ItemProjectRes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ITEMPROJECTRES';
  #
  # The MIT License (MIT)
  #
  # Copyright (c) 2015 yaalaa
  #
  # Permission is hereby granted, free of charge, to any person obtaining a copy
  # of this software and associated documentation files (the "Software"), to deal
  # in the Software without restriction, including without limitation the rights
  # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  # copies of the Software, and to permit persons to whom the Software is
  # furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all
  # copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  # SOFTWARE.
  #
  #
  # Resource project
  #
  package ItemProjectRes;
  
  
  use strict;
  use CommonUtils;
  use Scalar::Util qw(blessed);
  use Data::Dumper;
  
  
  #
  # Initializes object
  # 
  # @param root   - project root folder
  # @param source - type of source of the project (android, etc.)
  #
  # @return initialized object
  #
  sub new
  {
      my ( $class, $root, $source ) = @_;
  
      my $self = bless 
      {
          root => $root,
          source => $source,
          langs => undef,
          baseFile => undef,
          files => {},
      }, $class;
      
      return $self;
  }
  
  #
  # Retrieves project root folder
  #
  # @return project root folder
  #
  sub getRoot
  {
      my $self = shift;
  
      return $self->{root};
  }
  
  #
  # Retrieves project source type
  #
  # @return project source type
  #
  sub getSource
  {
      my $self = shift;
  
      return $self->{source};
  }
  
  #
  # Checks whether it has translation to specified language
  #
  # @param lang - language
  #
  # @return !=0, if it has translation to specified language
  #
  sub hasTranslation
  {
      my ( $self, $lang ) = @_;
      
      my $out = 0;
      
      {{
          my $langs = $self->getLangs();
          
          $out = exists $langs->{$lang} ? 1 : 0;
      }}
  
      return $out;
  }
  
  #
  # Retrieves list of languages of existing translations
  #
  # @return list of languages of existing translations(hash: lang->filename)
  #
  sub getLangs
  {
      my ( $self, $lang ) = @_;
      
      my $out;
      
      {{
          my $langs = $self->{langs};
          
          if ( !defined( $langs ) ) # not loaded yet
          {
              if ( ! defined $self->can( "_loadLangs" ) ) #  method is not supported
              {
                  printf "ItemProjectRes::getLangs: no _loadLangs provided in [%s]\n", blessed( $self );
                  last;
              }
          
              $langs = $self->_loadLangs();
              
              $self->{langs} = $langs;
          }
          
          $out = $langs;
      }}
  
      return $out;
  }
  
  #
  # Retrieves base resource file
  #
  # @return resource file as ItemFileRes, if succeeded
  #
  sub getResBase
  {
      my $self = shift;
      
      my $out;
      
      {{
          $out = $self->{baseFile};
          
          if ( !defined( $out ) ) # not loaded yet
          {
              if ( ! defined $self->can( "_loadResBase" ) ) #  method is not supported
              {
                  printf "ItemProjectRes::getResBase: no _loadResBase provided in [%s]\n", blessed( $self );
                  last;
              }
          
              $out = $self->_loadResBase();
              
              $self->{baseFile} = $out;
          }
      }}
  
      return $out;
  }
  
  #
  # Retrieves resource file for specified language
  #
  # @param lang - language
  #
  # @return resource file as ItemFileRes, if succeeded
  #
  sub getResForLang
  {
      my ( $self, $lang ) = @_;
      
      my $out;
      
      {{
          if ( $lang eq "" ) # no langauge
          {
              last;
          }
          
          if ( exists $self->{files}->{$lang} ) # loaded
          {
              $out = $self->{files}->{$lang};
              last;
          }
          
          my $langs = $self->getLangs();
      
          if ( !defined( $langs ) )  # no translation at all
          {
              last;
          }
          
          if ( ! exists $langs->{$lang} ) # no translation found
          {
              last;
          }
  
          # found 
          # will try to load
          
          if ( ! defined $self->can( "_loadResForLang" ) ) #  method is not supported
          {
              printf "ItemProjectRes::getResForLang: no _loadResForLang provided in [%s]\n", blessed( $self );
              last;
          }
          
          $out = $self->_loadResForLang( $lang );
          
          if ( !defined( $out ) ) # not loaded
          {
              last;
          }
          
          $self->{files}->{$lang} = $out;
      }}
  
      return $out;
  }
  
  #
  # Saves not translated items to CSV file
  #
  # @param lang     - language to check
  # @param fileName - output CSV file name
  #
  # @return !=0, if succeeded
  #
  sub saveNotTraslatedToCsv
  {
      my ( $self, $lang, $fileName ) = @_;
      
      my $out = 0;
  
      my $file;
      
      {{
          if ( !defined( $lang ) || $lang eq "" ) # no language
          {
              printf "ItemProjectRes::saveNotTraslatedToCsv: no language specified\n";
              last;
          }
      
          if ( $fileName eq "" ) # no filename
          {
              printf "ItemProjectRes::saveNotTraslatedToCsv: no filename specified\n";
              last;
          }
          
          my $resBase = $self->getResBase();
          
          if ( !defined( $resBase ) ) # no base resource
          {
              printf "ItemProjectRes::saveNotTraslatedToCsv: no base resource\n";
              last;
          }
          
          my $resLang = $self->getResForLang( $lang );
          
          my $items = $resBase->getItems();
          
          my $csv;
          
          my $ok = 1;
          
          my $notTranslatedCnt = 0;
          
          for my $curItem ( @$items )
          {
              if ( !$curItem->isTranslatable() || $curItem->isAlias() ) # item is not tranlatable or it's alias to another resource
              {
                  next;
              }
              
              my $id = $curItem->getId();
              
              my $found;
              
              if ( defined( $resLang ) ) # has translation file
              {
                  $found = $curItem->isPlural() ? $resLang->getItemPluralById( $id ) : $resLang->getItemPlainById( $id );
              }
              
              if ( defined( $found ) )  # found translation
              {
                  next;
              }
              
              if ( !defined( $file ) ) # not opened yet
              {
                  if ( !open( $file, ">:raw:encoding(UTF-8)", $fileName ) ) # failed
                  {
                      printf "ItemProjectRes::saveNotTraslatedToCsv: open failed[%s]: %s\n", $fileName, $!;
                      $ok = 0;
                      last;
                  }
                  
                  $csv = Text::CSV_XS->new( { binary => 1, eol => $/ } );
  
                  if ( !$csv->print( $file, [ "ID", "Modifier", "Original", "Translation" ] ) ) # failed
                  {
                      printf "ItemProjectRes::saveNotTraslatedToCsv: csv::print failed: %s\n", $csv->status();
                      $ok = 0;
                      last;
                  }
  
                  if ( !$csv->print( $file, [ "", "", "", "" ] ) ) # failed
                  {
                      printf "ItemProjectRes::saveNotTraslatedToCsv: csv::print failed: %s\n", $csv->status();
                      $ok = 0;
                      last;
                  }
              }
              
              if ( !$curItem->isPlural() )
              {
                  if ( !$csv->print( $file, [ $id, "", $curItem->getText()->getData(), "" ] ) ) # failed
                  {
                      printf "ItemFileRes::saveItemsToCsv: csv::printf failed: %s\n", $csv->status();
                      $ok = 0;
                      last;
                  }
              } 
              else 
              {
                  if ( !$csv->print( $file, [ $id, "", "", "" ] ) ) # failed
                  {
                      printf "ItemFileRes::saveItemsToCsv: csv::printf failed: %s\n", $csv->status();
                      $ok = 0;
                      last;
                  }
  
                  for my $curVariant ( @$ItemTextRes::VARIANTS ) 
                  {
                      my $text = $curItem->getVariant( $curVariant );
                      
                      my $s = defined( $text ) ? $text->getData() : "";
                      
                      if ( !$csv->print( $file, [ "", $curVariant, $s, "" ] ) ) # failed
                      {
                          printf "ItemFileRes::saveItemsToCsv: csv::printf failed: %s\n", $csv->status();
                          $ok = 0;
                          last;
                      }
                  }
                  
                  if ( !$ok ) # failed
                  {
                      last;
                  }
              }
              
              $notTranslatedCnt++;
          }
          
          if ( !$ok )
          {
              last;
          }
          
          if ( $notTranslatedCnt > 0 )
          {
              printf "ItemFileRes::saveItemsToCsv: %d items to translate to[%s]\n", $notTranslatedCnt, $lang;
          } 
          else
          {
              printf "ItemFileRes::saveItemsToCsv: [%s] is translated completely\n", $lang;
          }
          
          $out = 1;
      }}
      
      if ( defined( $file ) )
      {
          close( $file );
      }
      
      return $out;
  }
  
  #
  # Merges existing and new translations
  #
  # @param lang - language
  # @param news - new translations as ItemFileRes
  # 
  # @return merged in ItemFileRes, if succeeded
  #
  sub mergeTranslation
  {
      my ( $self, $lang, $news ) = @_;
      
      my $out;
      
      {{
          if ( !defined( $lang ) || $lang eq "" ) # no language
          {
              printf "ItemProjectRes::mergeTranslation: no language specified\n";
              last;
          }
      
          if ( !defined( $news ) ) # no news
          {
              printf "ItemProjectRes::mergeTranslation: no news specified\n";
              last;
          }
          
          if ( !( blessed( $news ) && $news->isa( "ItemFileRes" ) ) ) # not an instance of ItemFileRes
          {
              printf "ItemProjectRes::mergeTranslation: no news is of unsupported type:[%s]\n", blessed( $news );
              last;
          }
          
          my $resBase = $self->getResBase();
          
          if ( !defined( $resBase ) ) # no base resource
          {
              printf "ItemProjectRes::mergeTranslation: no base resource\n";
              last;
          }
          
          my $resLang = $self->getResForLang( $lang );
  
          if ( ! defined $self->can( "_createRes" ) ) #  method is not supported
          {
              printf "ItemProjectRes::mergeTranslation: no _createRes provided in [%s]\n", blessed( $self );
              last;
          }
          
          my $merge = $self->_createRes( "", $lang );
          
          if ( !defined( $merge ) ) # failed
          {
              printf "ItemProjectRes::mergeTranslation: _createRes failed\n";
              last;
          }
          
          my $baseItemsExt = $resBase->getItemsExt();
          
          my $ok = 1;
          
          my $cntTotal = 0;
          my $cntTranslated = 0;
          my $cntAdded = 0;
          my $cntOverridden = 0;
          
          for my $curItem ( @{ $baseItemsExt } )
          {
              my $toAdd = $curItem;
              
              if ( $curItem->isa( "ItemTextRes" ) ) # text resource
              {
                  undef $toAdd;
                  
                  {{
                      if ( !$curItem->isTranslatable() || $curItem->isAlias() ) # not tranlatable or alias
                      {
                          last;
                      }
                      
                      $cntTotal++;
                      
                      my $id = $curItem->getId();
                      my $plural = $curItem->isPlural();
                      
                      my $oldItem;
  
                      if ( defined( $resLang ) ) # has old translation
                      {
                          $oldItem = $resLang->getItemById( $id, $plural );
                      }
                      
                      my $newItem = $news->getItemById( $id, $plural );
                      
                      $toAdd = defined( $newItem ) ? $newItem : $oldItem;
                      
                      if ( !defined( $toAdd ) ) # still no translation 
                      {
                          last;
                      }
                      
                      if ( defined( $newItem ) && defined( $oldItem ) ) # new item will override old one
                      {
                          $cntOverridden++;
                      }
                      elsif ( defined( $newItem ) ) # pure new item
                      {
                          $cntAdded++;
                      }
                      
                      $cntTranslated++;
                  }}
              }
              
              if ( !defined( $toAdd ) )
              {
                  next;
              }
              
              if ( !$merge->addItem( $toAdd ) ) # failed
              {
                  $ok = 1;
                  last;
              }
          }
          
          if ( !$ok ) # failed
          {
              last;
          }
          
          my $percent = 0;
          
          if ( $cntTotal > 0 )
          {
              $percent = 100.0 * $cntTranslated / $cntTotal;
          }
          
          printf "[%s] status: %.2f%% added: %d overridden: %d\n", $lang, $percent, $cntAdded, $cntOverridden;
          
          if ( $cntAdded + $cntOverridden <= 0 ) # no news
          {
              last;
          }
          
          $out = $merge;
      }}
      
      return $out;
  }
  
  #
  # Prints summary report
  #
  # @param options - options
  #
  # @return !=0, if succeeded
  #
  sub reportSummary
  {
      my ( $self, $options ) = @_;
      
      my $out = 0;
      
      {{
          my $resBase = $self->getResBase();
          
          if ( !defined( $resBase ) ) # no base resource
          {
              printf "ItemProjectRes::reportSummary: no base resource\n";
              last;
          }
          
          my $items = $resBase->getItems();
          
          my $cntTotal = 0;
          my $cntPlain = 0;
          my $cntPlural = 0;
          
          for ( @{ $items } )
          {
              if ( !$_->isTranslatable() ) # non-translatable
              {
                  next;
              }
              
              if ( $_->isAlias() ) # alias
              {
                  next;
              }
              
              $cntTotal++;
              
              if ( !$_->isPlural() ) # plain
              {
                  $cntPlain++;
              }
              else
              {
                  $cntPlural++;
              }
          }
          
          printf "Items: total %d (plurals %d)\n", $cntTotal, $cntPlural;
          
          if ( $cntTotal <= 0 ) # no item to translate
          {
              $out = 1;
              last;
          }
          
          my $langs = $self->getLangs();
          
          if ( !defined( $langs ) ) # failed
          {
              printf "ItemProjectRes::reportSummary: getLangs failed\n";
          }
          
          my @langsSorted = sort { CORE::fc($a) cmp CORE::fc($b) } keys %$langs;
  
          my $cntLangs = scalar( @langsSorted );
          
          if ( $cntLangs <= 0 ) # no translation
          {
              printf "No translation yet\n";
              $out = 1;
              last;
          }
          
          printf "Language count: %d\n", $cntLangs;
          printf "Languages: %s\n", join( " ", @langsSorted );
          
          my $totalNotTranslated = 0;
          
          for my $lang ( @langsSorted )
          {
              my $res = $self->getResForLang( $lang );
              
              if ( !defined( $res ) ) # failed
              {
                  last;
              }
              
              my $cntTranslated = 0;
              
              for my $item ( @{ $items } )
              {
                  if ( defined( $res->getItemById( $item->getId(), $item->isPlural() ) ) )
                  {
                      $cntTranslated++;
                  }
              }
              
              if ( $cntTranslated < $cntTotal )
              {
                  printf "[%s] %.2f% translated\n", $lang, ( 100.0 * $cntTranslated / $cntTotal );
                  
                  $totalNotTranslated += ( $cntTotal - $cntTranslated );
              }
              else
              {
                  printf "[%s] 100% translated\n", $lang;
              }
          }
  
          printf "\nItems to translate: %d\n", $totalNotTranslated;
          
          $out = 1;
      }}
      
      return $out;
  }
  
  1;
ITEMPROJECTRES

$fatpacked{"ItemText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ITEMTEXT';
  #
  # The MIT License (MIT)
  #
  # Copyright (c) 2015 yaalaa
  #
  # Permission is hereby granted, free of charge, to any person obtaining a copy
  # of this software and associated documentation files (the "Software"), to deal
  # in the Software without restriction, including without limitation the rights
  # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  # copies of the Software, and to permit persons to whom the Software is
  # furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all
  # copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  # SOFTWARE.
  #
  #
  # Text string and related information
  #
  package ItemText;
  
  
  use strict;
  use CommonUtils;
  
  #
  # Initializes object
  # 
  # @param s - text string
  #
  # @return initialized object
  #
  sub new
  {
      my ( $class, $s ) = @_;
  
      my $self = bless 
      {
          data => $s
      }, $class;
  
      return $self;
  }
  
  #
  # Retrieves text string
  # 
  # @return text string
  #
  sub getData
  {
      my $self = shift;
      
      return $self->{data};
  }
  
  1;
ITEMTEXT

$fatpacked{"ItemTextRes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ITEMTEXTRES';
  #
  # The MIT License (MIT)
  #
  # Copyright (c) 2015 yaalaa
  #
  # Permission is hereby granted, free of charge, to any person obtaining a copy
  # of this software and associated documentation files (the "Software"), to deal
  # in the Software without restriction, including without limitation the rights
  # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  # copies of the Software, and to permit persons to whom the Software is
  # furnished to do so, subject to the following conditions:
  #
  # The above copyright notice and this permission notice shall be included in all
  # copies or substantial portions of the Software.
  #
  # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  # SOFTWARE.
  #
  # Text resource
  #
  package ItemTextRes;
  
  
  use strict;
  use CommonUtils;
  use ItemText;
  use Scalar::Util qw(blessed reftype);
  use Data::Dumper;
  
  
  #
  # Denotes plain text string resource
  #
  my $TYPE_PLAIN = "plain";
  #
  # Denotes plural text string resource
  #
  my $TYPE_PLURAL = "plural";
  #
  # Denotes ONE plural variant
  #
  my $PLURAL_ONE = "one";
  #
  # Denotes TWO plural variant
  #
  my $PLURAL_TWO = "two";
  #
  # Denotes FEW plural variant
  #
  my $PLURAL_FEW = "few";
  #
  # Denotes MANY plural variant
  #
  my $PLURAL_MANY = "many";
  #
  # Denotes OTHER plural variant
  #
  my $PLURAL_OTHER = "other";
  
  #
  # Plural variants
  #
  our $VARIANTS = [
      $PLURAL_ONE,
      $PLURAL_TWO,
      $PLURAL_FEW,
      $PLURAL_MANY,
      $PLURAL_OTHER,
  ];
  #
  # Maps plural variant to member name
  #
  my $_VARIANT_FIELDS = {
      $PLURAL_ONE => $PLURAL_ONE,
      $PLURAL_TWO => $PLURAL_TWO,
      $PLURAL_FEW => $PLURAL_FEW,
      $PLURAL_MANY => $PLURAL_MANY,
      $PLURAL_OTHER => $PLURAL_OTHER,
  };
  
  #
  # Initializes object
  # 
  # @param type - resource type, @see TYPE_XXX constants
  # @param id   - identifier
  #
  # @return initialized object
  #
  sub new
  {
      my ( $class, $id, $options ) = @_;
      
      my $plural = 0;
      my $translatable = 1;
      my $alias = 0;
      
      if ( reftype $options == "HASH" )  # options are specified
      {
          if ( $options->{plural} )
          {
              $plural = 1;
          }
          
          if ( $options->{nontranslatable} )
          {
              $translatable = 0;
          }
          
          if ( $options->{alias} )
          {
              $alias = 1;
          }
      }
  
      my $self = bless 
      {
          id => $id,
          plural => $plural,
          translatable => $translatable,
          alias => $alias,
      }, $class;
      
      return $self;
  }
  
  #
  # Retrieves ID
  #
  # @return ID
  #
  sub getId
  {
      my $self = shift;
  
      return $self->{id};
  }
  
  #
  # Checks whether it's plural resource
  #
  # @return 1, if it's plural resource
  #
  sub isPlural
  {
      my $self = shift;
  
      return $self->{plural};
  }
  
  #
  # Checks whether it's translatable resource
  #
  # @return 1, if it's translatable resource
  #
  sub isTranslatable
  {
      my $self = shift;
  
      return $self->{translatable};
  }
  
  #
  # Checks whether it's alias to another resource
  #
  # @return 1, if it's alias to another resource
  #
  sub isAlias
  {
      my $self = shift;
  
      return $self->{alias};
  }
  
  #
  # Sets/resets alias flag
  #
  # @param value - !0, to set alias flag
  #
  sub setAlias
  {
      my ( $self, $value ) = @_;
  
      $self->{alias} = $value != 0 ? 1 : 0;
  }
  
  #
  # Retrieves text.
  # Works for plain resources.
  #
  # @return text as ItemText, if any
  #
  sub getText
  {
      my $self = shift;
  
      return $self->{text};
  }
  
  #
  # Sets text.
  # Works for plain resources.
  #
  # @param text - text as ItemText
  #
  sub setText
  {
      my ( $self, $text ) = @_;
      
      if ( ! defined( $text ) )
      {
          delete $self->{text};
      }
      elsif ( blessed $text && $text->isa( "ItemText" ) )
      {
          $self->{text} = $text;
      } 
      else # unsupported type
      {
          printf "ItemTextRes::setText: unsupported type:[%s]\n", blessed( $text );
      }
  }
  
  #
  # Retrieves plural variant text.
  # Works for plural resources.
  #
  # @param variant - plural variant, @see PLURAL_XXX constants
  #
  # @return text as ItemText, if any
  #
  sub getVariant
  {
      my ( $self, $variant ) = @_;
      
      my $out;
      
      {{
          if ( !$self->isPlural() ) # not a plural
          {
              printf "ItemTextRes::getVariant: not a plural\n";
              last;
          }
          
          if ( !defined( $variant ) ) # no variant
          {
              printf "ItemTextRes::getVariant: no variant\n";
              last;
          }
          
          if ( ! exists $_VARIANT_FIELDS->{$variant} ) # unsupported variant
          {
              printf "ItemTextRes::getVariant: unsupported variant: [%s]\n", $variant;
              last;
          }
          
          my $field = $_VARIANT_FIELDS->{$variant};
          
          $out = $self->{$field};
      }}
  
      return $out;
  }
  
  #
  # Sets plural variant text.
  # Works for plural resources.
  #
  # @param variant - plural variant, @see PLURAL_XXX constants
  # @param text    - text as ItemText
  #
  sub setVariant
  {
      my ( $self, $variant, $text ) = @_;
      
      my $out;
      
      {{
          if ( !$self->isPlural() ) # not a plural
          {
              printf "ItemTextRes::setVariant: not a plural\n";
              last;
          }
          
          if ( !defined( $variant ) ) # no variant
          {
              printf "ItemTextRes::setVariant: no variant\n";
              last;
          }
          
          if ( ! exists $_VARIANT_FIELDS->{$variant} ) # unsupported variant
          {
              printf "ItemTextRes::setVariant: unsupported variant: [%s]\n", $variant;
              last;
          }
          
          my $field = $_VARIANT_FIELDS->{$variant};
  
          if ( !defined( $text ) )
          {
              delete $self->{$field};
              last;
          }
  
          if ( blessed $text && $text->isa( "ItemText" ) )
          {
              $self->{$field} = $text;
              last;
          }
          
          printf "ItemTextRes::setVariant: unsupported type:[%s]\n", blessed( $text );
    }}
  
      return $out;
  }
  
  #
  # Checks whether it has no text
  #
  # @return !=0, if it has no text
  #
  sub isEmpty
  {
      my $self = shift;
      
      my $out = 0;
      
      if ( !$self->isPlural() ) # plain text
      {
          if ( !defined( $self->getText() ) )
          {
              $out = 1;
          }
      }
      else # plural
      {
          $out = 1;
          
          for my $curVariant ( @{ $VARIANTS } )
          {
              my $field = $_VARIANT_FIELDS->{$curVariant};
              
              if ( defined( $self->{$field} ) )
              {
                  $out = 0;
                  last;
              }
          }
      }
      
      return $out;
  }
  
  
  
  
  1;
ITEMTEXTRES

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#
# The MIT License (MIT)
#
# Copyright (c) 2015 yaalaa
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
#
# Manages translations, source and exported
#

BEGIN
{
    use File::stat;
    use File::Spec::Functions qw(rel2abs);
    use File::Basename;

    my $myDir = dirname( rel2abs( __FILE__ ) );

    push( @INC, $myDir."/lib" );
}


use strict;
use Getopt::Long;
use CommonUtils;
use ItemAndroidProjectRes;
use ItemIosProjectRes;
use ItemFileRes;

$|=1;

# hello message
printf "%s Hi there, I'm %s\n", CommonUtils::GetTimeStr(), $0;

my $usage = <<EOT;
Helps in exporting/importing translations

Usage:
  <me> command [option ..]
  
  Commands:
    n|print-not-translated   - prints not translated items for specified language
    a|apply-new-translations - merges new translations for specified language
    i|summary-report         - prints summary report
  
  Options:
    --help                  - this help screen
    --android <path>        - specifies Android project root folder
    --ios <path>            - specifies iOS project root folder
    --out-csv <path>        - specifies output CSV file
    --out-xml <path>        - output XML file (for Android project)
    --out-strings <path>    - output strings file (for iOS project)
    --in-csv <path>         - specifies input CSV file
    --lang <lang>           - langauge to operate for

EOT

if ( scalar( @ARGV ) <= 0 ) # no arguments
{
    printf $usage;
    exit( 0 );
}

my $cmd = shift( @ARGV );

my $needLang = 0;

my $cmdPrintNotTranslated = 0;
my $cmdApplyNewTranslations = 0;
my $cmdReportSummary = 0;

if ( ( $cmd eq "n" ) || ( $cmd eq "print-not-translated" ) )
{
    $cmdPrintNotTranslated = 1;
    $needLang = 1;
}
elsif ( ( $cmd eq "a" ) || ( $cmd eq "apply-new-translations" ) )
{
    $cmdApplyNewTranslations = 1;
    $needLang = 1;
}
elsif ( ( $cmd eq "i" ) || ( $cmd eq "summary-report" ) )
{
    $cmdReportSummary = 1;
}
elsif ( ( $cmd eq "help" ) || ( $cmd eq "--help" ) || ( $cmd eq "-h" ) || ( $cmd eq "-?" ) )
{
    printf $usage;
    exit( 0 );
}
else # not a command
{
    printf "Not a command: %s\n\n", $cmd;
    printf $usage;
    exit( 0 );
}

my $optResult = GetOptions( 
    "help"          => \my $printHelp,
    "android=s"     => \my $optAndroid,
    "ios=s"         => \my $optIos,
    "out-csv=s"     => \my $optOutCsv,
    "out-xml=s"     => \my $optOutXml,
    "out-strings=s" => \my $optOutStrings,
    "in-csv=s"      => \my $optInCsv,
    "lang=s"        => \my $optLang,
    );

if ( !$optResult || $printHelp )
{
    printf $usage;
    exit( 0 );
}

if ( !defined( $optAndroid ) && !defined( $optIos ) ) # no project
{
    printf "Please, specify project.\nTry --help\n";
    exit( 0 );
}

if ( $needLang && 
    !$optLang ) # no language
{
    printf "Please, specify language.\nTry --help\n";
    exit( 0 );
}

# execute commands
if ( $cmdPrintNotTranslated ) # to print not translated items
{
    if ( !defined( $optOutCsv ) || $optOutCsv eq "" ) # no output
    {
        printf "Please, specify CSV output filename.\nTry --help\n";
        exit( 0 );
    }

    if ( defined( $optOutCsv ) ) # check for future
    {
        unlink( $optOutCsv );
    }
    
    my $prj;
    
    if ( defined( $optAndroid ) ) # android
    {
        $prj = ItemAndroidProjectRes->new( $optAndroid );
    }
    elsif ( defined( $optIos ) ) # ios
    {
        $prj = ItemIosProjectRes->new( $optIos );
    }
    else # no project
    {
        printf "Please, specify project.\nTry --help\n";
        exit( 0 );
    }

    if ( !$prj->saveNotTraslatedToCsv( $optLang, $optOutCsv ) ) # failed
    {
        printf "saveNotTraslatedToCsv failed\n";
    }
    
}
elsif ( $cmdApplyNewTranslations ) # to apply new translations
{
    if ( !defined( $optInCsv ) || $optInCsv eq "" ) # no input
    {
        printf "Please, specify CSV input filename.\nTry --help\n";
        exit( 0 );
    }

    my $prj;
    
    if ( defined( $optAndroid ) ) # android
    {
        $prj = ItemAndroidProjectRes->new( $optAndroid );

        if ( !defined( $optOutXml ) || $optOutXml eq "" ) # no output
        {
            printf "Please, specify XML output filename.\nTry --help\n";
            exit( 0 );
        }

        if ( defined( $optOutXml ) ) # check for future
        {
            unlink( $optOutXml );
        }
    }
    elsif ( defined( $optIos ) ) # ios
    {
        $prj = ItemIosProjectRes->new( $optIos );

        if ( !defined( $optOutStrings ) || $optOutStrings eq "" ) # no output
        {
            printf "Please, specify strings output filename.\nTry --help\n";
            exit( 0 );
        }

        if ( defined( $optOutStrings ) ) # check for future
        {
            unlink( $optOutStrings );
        }
    }
    else # no project
    {
        printf "Please, specify project.\nTry --help\n";
        exit( 0 );
    }

    
    my $news = ItemFileRes->new( "", "", $optLang );
    
    my $newsCount = $news->loadItemsFromCsv( $optInCsv );
    
    if ( $newsCount <= 0 ) # no news
    {
        printf "No new item is found.\n";
        exit( 0 );
    }

    #printf "%d new item is found.\n", $newsCount;
    
    my $merge = $prj->mergeTranslation( $optLang, $news );
    
    if ( !defined( $merge ) ) # failed on no news
    {
        exit( 0 );
    }

    if ( $prj->getSource() eq $ItemAndroidProjectRes::SOURCE ) # android
    {
        if ( !$merge->saveToXml( $optOutXml ) ) # failed
        {
            #printf "saveToXml failed\n";
            exit( 0 );
        }
    }
    elsif ( $prj->getSource() eq $ItemIosProjectRes::SOURCE ) # iOS
    {
        if ( !$merge->save( $optOutStrings ) ) # failed
        {
            #printf "save failed\n";
            exit( 0 );
        }
    }
    else
    {
        # do nothing for now
    }
}
elsif ( $cmdReportSummary ) # summary report
{
    my $prj;
    
    if ( defined( $optAndroid ) ) # android
    {
        $prj = ItemAndroidProjectRes->new( $optAndroid );
    }
    elsif ( defined( $optIos ) ) # ios
    {
        $prj = ItemIosProjectRes->new( $optIos );
    }
    else # no project
    {
        printf "Please, specify project.\nTry --help\n";
        exit( 0 );
    }
    
    if ( !$prj->reportSummary() ) # failed
    {
        exit( 0 );
    }
}


printf "%s .Done.\n", CommonUtils::GetTimeStr();

exit( 0 );

#-----------------------------------------------------------------------------------------------------------


